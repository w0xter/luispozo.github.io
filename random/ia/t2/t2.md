#Inteligencia Artificial: Busqueda de Espacios de Estado.

##Definiciones:
- **Estado:** Un Estado es la representaci√≥n de los elementos que describen un problema concreto en un momento dado. Todos los estados que definamos ser√°n una *SubClase* de **BaseState** tendr√°n un sucesor y una funci√≥n para calcular si dos estados son iguales.

```PYTHON
class BaseState(metaclass=abc.ABCMeta):

    @abc.abstractmethod
    def successors(self):
        raise NotImplementedError()

    @abc.abstractmethod
    def equals(self, other):
        raise NotImplementedError()

    def __eq__(self, other):
        return self.equals(other)


```
- **Sucesores:** Son los estados que se puden alcanzar partiendo del estado actual.
- **Camino:** El camino es la lista de **Nodos** (*Estados*) que hemos recorrido para llegar al estado actual.
- **Lista de Caminos Pendientes:** Lista que contiene todos los caminos que a√∫n no han sido explorados.
- **Reglas de Transci√≥n:** Reglas con las que decidiremos como elegir el siguiente *Estado*.
- **Heur√≠stica:** Funci√≥n que nos estima lo pr√≥xima que est√° la *soluci√≥n* de nuestro *Estado Actual*.
```PYTHON
def heuristic(state):
    # Operations and stuff
    return estimation_to_reach_the_goal
```
- **Coste:** Valor asociado a la transici√≥n de un estado a otro. Cuanto mayor es el valor mayor es el coste. En los problemas que se tiene en cuenta el coste lo ideal es buscar el menor coste posible.
```PYTHON
def cost(path):
    # Operations and stuff
    return how_much_does_the_path_cost
```
- **Poda:** M√©todo de eliminaci√≥n de caminos que llegan a estados a los que se puede llegar por otros caminos con menor coste.
```PYTHON
def bound(paths):
    """ Realiza una poda sobre una lista de caminos.

    Se espera que el conjunto de caminos est√© ordenado por coste. En caso de
    no ser as√≠, existe la posibilidad de podar caminos con un coste menor.

    :param paths: Una lista de caminos por explorar ordenados por coste.
    :return: La lista de caminos despu√©s de excluir los podados.
    """
    bounded_paths = []
    reached_nodes = []
    for path in paths:
        last_node = path[-1]
        if last_node not in reached_nodes:
            # S√≥lo lo a√±adimos si no ha sido alcanzado antes
            reached_nodes.append(last_node)
            bounded_paths.append(path)
    return bounded_paths
```
- **Estimador**: Funci√≥n que combina el *coste* y la *heur√≠stica* donde *g(x)* es la funci√≥n *coste* y *h(x)* es la funci√≥n *heur√≠stica* y *ùõº* es el factor que pondera la importancia de la *heur√≠stica*.S$$$‚Ñé^*(ùë•)=ùëî(ùë•)+ùõº‚Ñé(ùë•)$$$

---

##Algoritmo Base:

El algoritmo base funciona siempre de la misma manera, se parte de una lista con un √∫nico nodo (*Origen*). Despu√©s se exrtae le primer camino de la *lista de caminos pendientes* si este no es soluci√≥n se expande en base a sus *reglas de transici√≥n*. Integramos dichas expansiones en nuestro camino y volvemos a iterar. Este algoritmo se repetir√° hasta que se encuentre una soluci√≥n o hasta que no queden caminos por explorar.
Ejemplo de algoritmo Base:
```PYTHON
def search(algorithm, origin, solution):
    # La lista de caminos pendientes se inicia con el estado origen.
    cp = [[origin]]

    # Repetimos el algoritmo mientras haya caminos pendientes.
    while cp:

        # Cogemos el primer camino de la lista de caminos pendientes
        path = cp.pop(0)

        if solution(path):
            # Genial, hemos terminado
            return path
        else:
            # Vaya, seguimos buscando por los sucesores. Expandimos...
            last_state = path[-1]
            e = []
            for state in last_state.successors():
                if state not in path:  # As√≠ evitamos caminos c√≠clicos
                    expansion = path + [state]
                    e.append(expansion)
            # ... y concatenamos seg√∫n diga el algoritmo
            cp = algorithm(cp, e)

    # Si hemos salido del bucle, es porque no hab√≠a ning√∫n camino que
    # llegase al resultado
    return False
```
El par√°metro **algorithm** determinar√° la funci√≥n con la que se combinar√° la lista de caminos pendientes con las expansiones.
Los parametros **origin** y **solution** son el estado inicial y el estado que queremos alcanzar.

---

##Algoritmos de Recombinaci√≥n:

Hemos indicado que el algoritmo concreto de reordenaci√≥n o recombinaci√≥n es una funci√≥n que le pasamos por el parametro **algorithm** Esta funci√≥n deber√° tomar como input un *Lista de caminos pendientes* y una *Lista de Expansiones* y devolver una **nueva** *Lista de caminos pendientes*.

---

##Ejemplos de Algoritmos de Recombinaci√≥n:
- ####Depth Search:
La b√∫squeda en profundidad (*Depth Search*) consiste en explorar primero los caminos expandidos para recorrer as√≠ el arbol de estados en profundidad.
```PYTHON
def depth_search(cp, e):
    """ Exploraci√≥n en profundidad.

    :param cp: La lista de caminos pendientes.
    :param e: La lista de caminos expansi√≥n.
    """
    return e + cp
```
- ####Breadth Search:
En este caso la b√∫squeda se realiza por los caminos m√°s cercanos y se va incrementando la profundidad a medida que estos se van explorando.
```PYTHON
def breadth_search(cp, e):
    """ Exploraci√≥n en amplitud.

    :param cp: La lista de caminos pendientes.
    :param e: La lista de caminos expansi√≥n.
    """
    return cp + e
```
- ###Hill Climbing:
El *m√©todo de la escalada* es el primero de los algoritmos que vemos que el concepto de heur√≠stica, y por tanto el primero que se considera *Inteligencia Artificial*.
Como nuestra funci√≥n de recombinaci√≥n espera dos listas de caminos, tenemos que hacer un peque√±o truco. Crearemos una funci√≥n a la que le pasaremos la *heur√≠stica*, y esta funci√≥n devolver√° otra funci√≥n con la **firma** (los par√°metro de entrada y salida) que necesitamos.
```PYTHON
def hill_climbing(heuristic):
    """ M√©todo de la escalada.

    :param heuristic: Funci√≥n que nos da la calidad de un estado en concreto.
    :return: La funci√≥n de recombinaci√≥n de caminos pendientes y expansiones.
    """

    def f(cp, e):
        order = lambda path: heuristic(path[-1])
        return sorted(e, key=order) + cp

    return f
```
- ###Best First:
El algoritmo de *primero el mejor* es parfecido al m√©todo de la escalada pero en vez de ordenar las expansiones por su heur√≠stica y luego concatenarlas a los caminos pendientes ahora se concatenan las expansiones con los caminos pendientes y despu√©s se reoredenadn por su eur√≠stica.
```PYTHON
def best_first(heuristic):
    """ M√©todo de "Primero el mejor".

    :param heuristic: Funci√≥n que nos da la calidad de un estado en concreto.
    :return: La funci√≥n de recombinaci√≥n de caminos pendientes y expansiones.
    """

    def f(cp, e):
        order = lambda path: heuristic(path[-1])
        return sorted(cp + e, key=order)

    return f
```
- ###Branch And Bound:
El m√©todo *Branch and Bound* utiliza el concepto de *poda* y *coste*. El funcionamiento es igual que *Best First* pero esta vez ordenado por *coste* y usando la *poda*.
```PYTHON
def branch_and_bound(cost):
    """ M√©todo "Branch and bound".

    :param cost: Funci√≥n que nos da el coste de un camino en concreto.
    :return: La funci√≥n de recombinaci√≥n de caminos pendientes y expansiones.
    """

    def f(cp, e):
        order = lambda path: cost(path)
        return bound(sorted(cp + e, key=order))

    return f
```
Al ordenar siempre por *coste* nos garantizamos una soluci√≥n √∫nica pero no est√° considerado **AI** porque no tiene en cuenta un *heur√≠stica* que guie su funcionamiento.
- ###A*
El m√©todo A* combina los conceptos de coste y heur√≠stica en un √∫nico m√©todo. Haciendo uso de la funci√≥n *estimador*.
```PYTHON
def a_star(cost=None, heuristic=None, alpha=None):
    """ M√©todo "A*".

    Se efectuar√° con una funci√≥n de estimaci√≥n de la forma:
    h*(s) = cost(s) + alpha * heuristic(s)

    :param cost: Funci√≥n que nos da el coste de un camino en concreto.
    :param heuristic: Funci√≥n que nos da la calidad de un estado en concreto.
    :param alpha: El grado de importancia de la heur√≠stica frente al coste.
    :return: La funci√≥n de recombinaci√≥n de caminos pendientes y expansiones.
    """
    alpha = alpha or 1.0
    def f(cp, e):
        order = lambda path: cost(path) + alpha * heuristic(path[-1])

        return bound(sorted(cp + e, key=order))

    return f
```
Este m√©todo nos garanitiza el camino de menor ciste siempre y cuando cumplamos la **condici√≥n de minorancia** (*tambi√©n conocida como heur√≠stica admisible*).

---

